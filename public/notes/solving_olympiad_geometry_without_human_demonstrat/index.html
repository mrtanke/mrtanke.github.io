<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Solving olympiad geometry without human demonstrations | Home</title><meta name=keywords content><meta name=description content="Paper-reading notes: AlphaGeometry"><meta name=author content><link rel=canonical href=https://my-blog-alpha-vert.vercel.app/notes/solving_olympiad_geometry_without_human_demonstrat/><link crossorigin=anonymous href=/assets/css/stylesheet.9bb7abd44394c0e0d2cecd8ad4322626054cd3f5709a6d890d5a408efaf1fa90.css integrity="sha256-m7er1EOUwODSzs2K1DImJgVM0/Vwmm2JDVpAjvrx+pA=" rel="preload stylesheet" as=style><link rel=icon href=https://my-blog-alpha-vert.vercel.app/selfile.png><link rel=icon type=image/png sizes=16x16 href=https://my-blog-alpha-vert.vercel.app/selfile.png><link rel=icon type=image/png sizes=32x32 href=https://my-blog-alpha-vert.vercel.app/selfile.png><link rel=apple-touch-icon href=https://my-blog-alpha-vert.vercel.app/selfile.png><link rel=mask-icon href=https://my-blog-alpha-vert.vercel.app/selfile.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://my-blog-alpha-vert.vercel.app/notes/solving_olympiad_geometry_without_human_demonstrat/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css integrity crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js integrity crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js integrity crossorigin=anonymous></script><script defer>document.addEventListener("DOMContentLoaded",function(){typeof renderMathInElement=="function"&&renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}],throwOnError:!1,ignoredTags:["script","noscript","style","textarea","pre","code"]})})</script><style>ul#menu .tag-button{background:0 0;border:none;padding:0;margin:0;font-weight:500;color:inherit;cursor:pointer;text-decoration:none;opacity:.95;display:inline-block}ul#menu .tag-button:hover{text-decoration:underline}ul#menu .tag-button.active{text-decoration:underline;font-weight:600}body.is-home .post-entry{display:none}body.is-home .page-footer .pagination{display:none}</style><script>(function(){function e(){const e=location.pathname.replace(/\/+/g,"/");return e==="/"||e===""||e==="/index.html"}e()&&document.body.classList.add("is-home"),document.addEventListener("DOMContentLoaded",function(){const e=document.getElementById("menu");if(!e)return;if(e.querySelector(".tag-button"))return;const n=["Notes","Thoughts","Projects"],t={Notes:"/notes/",Thoughts:"/thoughts/",Projects:"/projects/"};n.forEach(n=>{const o=document.createElement("li"),s=document.createElement("a");s.className="tag-button",s.href=t[n],s.textContent=n,location.pathname.toLowerCase().startsWith(t[n])&&s.classList.add("active"),o.appendChild(s),e.appendChild(o)})})})()</script><meta property="og:url" content="https://my-blog-alpha-vert.vercel.app/notes/solving_olympiad_geometry_without_human_demonstrat/"><meta property="og:site_name" content="Home"><meta property="og:title" content="Solving olympiad geometry without human demonstrations"><meta property="og:description" content="Paper-reading notes: AlphaGeometry"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="notes"><meta property="article:published_time" content="2025-11-28T08:42:56+00:00"><meta property="article:modified_time" content="2025-11-28T08:42:56+00:00"><meta property="og:image" content="https://my-blog-alpha-vert.vercel.app/notes/solving_olympiad_geometry_without_human_demonstrat/image.png"><meta property="og:image" content="https://my-blog-alpha-vert.vercel.app/notes/solving_olympiad_geometry_without_human_demonstrat/image_1.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://my-blog-alpha-vert.vercel.app/notes/solving_olympiad_geometry_without_human_demonstrat/image.png"><meta name=twitter:title content="Solving olympiad geometry without human demonstrations"><meta name=twitter:description content="Paper-reading notes: AlphaGeometry"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://my-blog-alpha-vert.vercel.app/notes/"},{"@type":"ListItem","position":2,"name":"Solving olympiad geometry without human demonstrations","item":"https://my-blog-alpha-vert.vercel.app/notes/solving_olympiad_geometry_without_human_demonstrat/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Solving olympiad geometry without human demonstrations","name":"Solving olympiad geometry without human demonstrations","description":"Paper-reading notes: AlphaGeometry","keywords":[],"articleBody":"Introduction Theorem proving is hard for ML because there are not enough human-written proofs in formal languages. Geometry is especially difficult because translating human geometric proofs into machine-verifiable form is very hard.\nCurrent geometry provers rely mainly on symbolic rules and hand-crafted heuristics, not learning. The authors solve the data shortage by generating 100 million synthetic theorems and proofs using symbolic engines.\nThey introduce dependency difference, which helps create nearly 10 million steps of auxiliary constructions. Auxiliary construction means adding new helper points; this creates infinite branching and is the hardest part of geometry proofs. The synthetic data lets the model learn auxiliary constructions without human demonstrations.\nThey train a language model on all synthetic proofs and fine-tune it to focus on auxiliary constructions. The symbolic engines handle all normal deduction steps, while the neural model generates new proof terms.\nThe resulting system, AlphaGeometry, proves geometry problems and produces human-readable proofs, performing close to an IMO gold medalist level.\nMethod Generate synthetic geometry data Random simple premises → symbolic engine → 100M synthetic theorems + proofs. Symbolic Engine is built manually: Deductive Database (DD) → Databse of deductive rules (symbolic rules) Algebraic Reasoning (AR) → Gaussian method (algebraic solver) Extract auxiliary constructions: Use dependency difference to find extra helper points (~10M). Dependency difference works like this:\nGenerate random geometry premises. Use symbolic engine to derive all proofs. For each conclusion, use traceback to find the minimal premises needed. Compare minimal premises vs. original premises. The difference gives extra points — interpreted as auxiliary constructions. These extra points become training examples for the language model. This teaches the model to generate helper points fully automatically, without human supervision.\nCompare the conclusion with its minimal required premises. Any extra points used along the way are treated as auxiliary constructions (~10M examples). These teach the model how to add helpful new points.\nTrain a Transformer model on serialized proofs. Feed it the serialized form of each synthetic theorem:\n.\nThe model learns how proofs and helper constructions look.\nNeuro-symbolic proof search: The symbolic engine tries to prove the input problem using known rules. If it cannot finish, the language model proposes a new helper point. Add the point → try symbolic engine again → repeat until solved. Think of AlphaGeometry as a student solving a geometry problem:\nStep 1: Try to solve it with what you already know\nThis is the Symbolic Engine.\nStep 2: If you’re stuck, add a new helper point\nThis is the Language Model.\nThen repeat. This cycle continues until the solution appears.\nNovelty Generate all training data synthetically\n→ No human proofs needed.\nIntroduce “dependency difference”\n→ Automatically learn auxiliary constructions (helper points).\nNeuro-symbolic loop\nSymbolic engine deduces Neural model adds new constructions when stuck. These three ideas together let AlphaGeometry reach near IMO gold-medalist level in geometry.\nNeural = intuition and exploration. Uses a neural network to propose new ideas when rules are not enough. Symbolic = logic and verification. Uses exact deduction rules to prune the search and ensure correctness. Neuro-symbolic = combine neural creativity + symbolic rigor to solve problems that require both exploration and precise reasoning.\n","wordCount":"522","inLanguage":"en","image":"https://my-blog-alpha-vert.vercel.app/notes/solving_olympiad_geometry_without_human_demonstrat/image.png","datePublished":"2025-11-28T08:42:56Z","dateModified":"2025-11-28T08:42:56Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://my-blog-alpha-vert.vercel.app/notes/solving_olympiad_geometry_without_human_demonstrat/"},"publisher":{"@type":"Organization","name":"Home","logo":{"@type":"ImageObject","url":"https://my-blog-alpha-vert.vercel.app/selfile.png"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://my-blog-alpha-vert.vercel.app/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches></div></div><ul id=menu><li><a class=tag-button href=https://my-blog-alpha-vert.vercel.app/notes/><span class=active>Notes</span></a></li><li><a class=tag-button href=https://my-blog-alpha-vert.vercel.app/thoughts/><span>Thoughts</span></a></li><li><a class=tag-button href=https://my-blog-alpha-vert.vercel.app/projects/><span>Projects</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://my-blog-alpha-vert.vercel.app/>Home</a>&nbsp;»&nbsp;<a href=/notes/>Notes</a></div><h1 class="post-title entry-hint-parent">Solving olympiad geometry without human demonstrations</h1><div class=post-description>Paper-reading notes: AlphaGeometry</div><div class=post-meta><span title='2025-11-28 08:42:56 +0000 +0000'>November 28, 2025</span>&nbsp;·&nbsp;<span>522 words</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#method aria-label=Method>Method</a><ul><li><a href=#generate-synthetic-geometry-data aria-label="Generate synthetic geometry data">Generate synthetic geometry data</a></li><li><a href=#extract-auxiliary-constructions aria-label="Extract auxiliary constructions:">Extract auxiliary constructions:</a></li><li><a href=#train-a-transformer-model-on-serialized-proofs aria-label="Train a Transformer model on serialized proofs.">Train a Transformer model on serialized proofs.</a></li><li><a href=#neuro-symbolic-proof-search aria-label="Neuro-symbolic proof search:">Neuro-symbolic proof search:</a></li></ul></li><li><a href=#novelty aria-label=Novelty>Novelty</a></li></ul></div></details></div><div class=post-content><h1 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h1><p><strong>Theorem proving is hard for ML</strong> because there are not enough human-written proofs in formal languages. <strong>Geometry is especially difficult</strong> because translating human geometric proofs into machine-verifiable form is very hard.</p><p>Current geometry provers rely mainly on <strong>symbolic rules and hand-crafted heuristics</strong>, not learning. The authors solve the data shortage by generating <strong>100 million synthetic theorems and proofs</strong> using symbolic engines.</p><p>They introduce <strong>dependency difference</strong>, which helps create nearly <strong>10 million steps of auxiliary constructions</strong>. <strong>Auxiliary construction</strong> means adding new helper points; this creates infinite branching and is the hardest part of geometry proofs. The synthetic data lets the model <strong>learn auxiliary constructions without human demonstrations</strong>.</p><p>They train a <strong>language model</strong> on all synthetic proofs and fine-tune it to focus on auxiliary constructions. The symbolic engines handle all normal deduction steps, while the neural model generates new proof terms.</p><p>The resulting system, <strong>AlphaGeometry</strong>, proves geometry problems and produces <strong>human-readable proofs</strong>, performing close to an IMO gold medalist level.</p><h1 id=method>Method<a hidden class=anchor aria-hidden=true href=#method>#</a></h1><h2 id=generate-synthetic-geometry-data><strong>Generate synthetic geometry data</strong><a hidden class=anchor aria-hidden=true href=#generate-synthetic-geometry-data>#</a></h2><ol><li>Random simple premises → <strong>symbolic engine</strong> → 100M synthetic theorems + proofs.</li><li>Symbolic Engine is built manually:<ol><li>Deductive Database (<strong>DD</strong>) → Databse of deductive rules (symbolic rules)</li><li>Algebraic Reasoning (<strong>AR</strong>) → Gaussian method (algebraic solver)</li></ol></li></ol><h2 id=extract-auxiliary-constructions><strong>Extract auxiliary constructions</strong>:<a hidden class=anchor aria-hidden=true href=#extract-auxiliary-constructions>#</a></h2><ol><li>Use <strong>dependency difference</strong> to find extra helper points (~10M).</li></ol><aside><p><strong>Dependency difference works like this:</strong></p><ol><li>Generate random geometry premises.</li><li>Use symbolic engine to derive all proofs.</li><li>For each conclusion, use traceback to find the minimal premises needed.</li><li>Compare minimal premises vs. original premises.</li><li>The difference gives extra points — interpreted as <strong>auxiliary constructions</strong>.</li><li>These extra points become training examples for the language model.</li></ol><p>This teaches the model to generate helper points <strong>fully automatically</strong>, without human supervision.</p></aside><p>Compare the conclusion with its minimal required premises. Any extra points used along the way are treated as <strong>auxiliary constructions</strong> (~10M examples). These teach the model how to add helpful new points.</p><h2 id=train-a-transformer-model-on-serialized-proofs><strong>Train a Transformer model</strong> on serialized proofs.<a hidden class=anchor aria-hidden=true href=#train-a-transformer-model-on-serialized-proofs>#</a></h2><ol><li><p>Feed it the serialized form of each synthetic theorem:</p><p><strong><premises><conclusion><proof></strong>.</p></li><li><p>The model learns how proofs and helper constructions look.</p></li></ol><p><img alt=image.png loading=lazy src=/notes/solving_olympiad_geometry_without_human_demonstrat/image.png></p><h2 id=neuro-symbolic-proof-search><strong>Neuro-symbolic proof search</strong>:<a hidden class=anchor aria-hidden=true href=#neuro-symbolic-proof-search>#</a></h2><ol><li>The symbolic engine tries to prove the input problem using known rules.</li><li>If it cannot finish, the language model proposes a <strong>new helper point</strong>.</li><li>Add the point → try symbolic engine again → repeat until solved.</li></ol><p><img alt=image.png loading=lazy src=/notes/solving_olympiad_geometry_without_human_demonstrat/image_1.png></p><aside><p>Think of AlphaGeometry as a <strong>student solving a geometry problem</strong>:</p><p><strong>Step 1: Try to solve it with what you already know</strong></p><p>This is the <strong>Symbolic Engine</strong>.</p><p><strong>Step 2: If you&rsquo;re stuck, add a new helper point</strong></p><p>This is the <strong>Language Model</strong>.</p><p>Then repeat. This cycle continues until the solution appears.</p></aside><h1 id=novelty>Novelty<a hidden class=anchor aria-hidden=true href=#novelty>#</a></h1><ol><li><p><strong>Generate all training data synthetically</strong></p><p>→ No human proofs needed.</p></li><li><p><strong>Introduce “dependency difference”</strong></p><p>→ Automatically learn auxiliary constructions (helper points).</p></li><li><p><strong>Neuro-symbolic loop</strong></p><ol><li>Symbolic engine deduces</li><li>Neural model adds new constructions when stuck.</li></ol></li></ol><p>These three ideas together let AlphaGeometry reach <strong>near IMO gold-medalist level</strong> in geometry.</p><aside><ul><li><strong>Neural = intuition and exploration.</strong><ul><li>Uses a neural network to propose new ideas when rules are not enough.</li></ul></li><li><strong>Symbolic = logic and verification.</strong><ul><li>Uses exact deduction rules to prune the search and ensure correctness.</li></ul></li></ul><p><strong>Neuro-symbolic = combine neural creativity + symbolic rigor
to solve problems that require both exploration and precise reasoning.</strong></p></aside></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>